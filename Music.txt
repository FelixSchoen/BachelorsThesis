from __future__ import annotations

from mido import MidiFile, MetaMessage, MidiTrack, Message
from enum import Enum
import numpy as np
import Music as mu


class Sequence:

    @staticmethod
    def stitch_together(sequences: list):
        sequence = Sequence()
        numerator = sequences[0].numerator
        denominator = sequences[0].denominator
        ticks = Musical.internal_ticks

        for seq in sequences:
            time = numerator / denominator * ticks * 4
            for element in seq.elements:
                if element.message_type == MessageType.wait:
                    time -= element.value
                sequence.elements.append(element)
            if time > 0 and not seq == sequences[-1]:
                sequence.elements.append(Element(MessageType.wait, time, Musical.std_velocity))

        sequence.numerator = numerator
        sequence.denominator = denominator
        return sequence


    def detect_ideal_scale(self) -> (list, list):
        mismatch = dict()

        for scale in Scale:
            mismatch[scale] = 0

        for element in self.elements:
            note_value = element.value % 12
            note = Note.from_note_value(note_value)
            for scale in Scale:
                if note not in scale.value:
                    mismatch[scale] += 1

        guess = sorted(mismatch.items(), key=lambda item: item[1])
        percentage = list(map(lambda x: 1 - x[1] / len(self.elements), guess))

        return sorted(mismatch.items(), key=lambda item: item[1]), percentage
