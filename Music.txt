from __future__ import annotations

from mido import MidiFile, MetaMessage, MidiTrack, Message
from enum import Enum
import numpy as np
import Music as mu


class Sequence:

    @staticmethod
    def stitch_together(sequences: list):
        sequence = Sequence()
        numerator = sequences[0].numerator
        denominator = sequences[0].denominator
        ticks = Musical.internal_ticks

        for seq in sequences:
            time = numerator / denominator * ticks * 4
            for element in seq.elements:
                if element.message_type == MessageType.wait:
                    time -= element.value
                sequence.elements.append(element)
            if time > 0 and not seq == sequences[-1]:
                sequence.elements.append(Element(MessageType.wait, time, Musical.std_velocity))

        sequence.numerator = numerator
        sequence.denominator = denominator
        return sequence

    def to_midi_file(self) -> MidiFile:
        midi_file = MidiFile()
        tpb = Musical.ticks_per_beat
        midi_file.ticks_per_beat = tpb
        midi_file.type = 1
        midi_file.tracks.append(self.to_midi_track())
        return midi_file

    def detect_ideal_scale(self) -> (list, list):
        mismatch = dict()

        for scale in Scale:
            mismatch[scale] = 0

        for element in self.elements:
            note_value = element.value % 12
            note = Note.from_note_value(note_value)
            for scale in Scale:
                if note not in scale.value:
                    mismatch[scale] += 1

        guess = sorted(mismatch.items(), key=lambda item: item[1])
        percentage = list(map(lambda x: 1 - x[1] / len(self.elements), guess))

        return sorted(mismatch.items(), key=lambda item: item[1]), percentage

    def split(self, numerator: int = -1, denominator: int = -1) -> list:
        if numerator == -1:
            numerator = self.numerator
        if denominator == -1:
            denominator = self.denominator
        max_duration = 4 * Musical.internal_ticks * (numerator / denominator)

        # Sequence in iteration to append
        seq = Sequence(numerator, denominator)
        # Generated Sequences
        seq_list = list()
        # Initial queue, instructions of the original sequence are in here
        initial_queue = self.elements.copy()
        # Carry queue, elements that need to be carried to the next bar contained in here
        carry_queue = list()

        # Duration of all elements in current iteration
        duration = 0
        # Values of notes that are open, used to close these at the end of an iteration
        open_notes = set()
        # Determines if current bar is done
        flag_end = False
        # Determines if carry queue should be used
        flag_carry = False

        while len(initial_queue) != 0 or len(carry_queue) != 0:
            if len(carry_queue) != 0 and flag_carry:
                element = carry_queue.pop(0)
            else:
                flag_carry = False
                element = initial_queue.pop(0)

            if element.message_type == MessageType.play:
                if duration < max_duration:
                    # Can play note in this bar
                    open_notes.add(WrappedElement(element))
                    seq.elements.append(element)
                else:
                    # Need to carry note to next bar
                    carry_queue.append(element)
            elif element.message_type == MessageType.stop:
                open_notes.remove(WrappedElement(element))
                seq.elements.append(element)
            elif element.message_type == MessageType.wait:
                if duration + element.value <= max_duration:
                    # Wait message fits in its entirety
                    duration += element.value
                    seq.elements.append(element)
                else:
                    # Wait does not fit
                    fit_duration = max_duration - duration
                    remainder_duration = element.value - fit_duration
                    duration += fit_duration
                    if fit_duration > 0:
                        seq.elements.append(Element(MessageType.wait, int(fit_duration), element.velocity))
                    carry_queue.append(Element(MessageType.wait, int(remainder_duration), element.velocity))
                    flag_end = True

            # Process ending of bar, add to list, close open notes
            if flag_end:
                flag_carry = True
                for open_note in open_notes.copy():
                    carry_queue.insert(0, open_note.element)
                    seq.elements.append(Element(MessageType.stop, open_note.element.value, Musical.std_velocity))
                    open_notes.remove(open_note)
                if seq.elements[-1].message_type == MessageType.wait:
                    seq.elements.pop(-1)
                seq_list.append(seq)
                seq = Sequence(numerator, denominator)
                duration = 0
                flag_end = False

        # Manually append last sequence, because it never triggers end detection
        seq_list.append(seq)
        return seq_list


class Musical:
    std_velocity = 64
    internal_ticks = 24
    ticks_per_beat = 96

    def __init__(self, right_hand: Sequence, left_hand: Sequence, numerator=4, denominator=4):
        self.right_hand = right_hand
        self.left_hand = left_hand
        self.numerator = numerator
        self.denominator = denominator

    @staticmethod
    def from_midi_file(right_hand: MidiFile, left_hand: MidiFile):
        seqr = Sequence.from_midi_file(right_hand)
        seql = Sequence.from_midi_file(left_hand)
        numerator = np.lcm(seqr.numerator, seql.numerator)
        denominator = np.lcm(seqr.denominator, seql.denominator)

        # Check if there are empty bars at the beginning
        wait_right = 0
        wait_right_velocity = Musical.std_velocity
        tpb = Musical.internal_ticks
        if seqr.elements[0].message_type == MessageType.wait:
            wait_right = seqr.elements[0].value
            wait_right_velocity = seqr.elements[0].velocity
        wait_left = 0
        wait_left_velocity = 64
        if seql.elements[0].message_type == MessageType.wait:
            wait_left = seql.elements[0].value
            wait_left_velocity = seql.elements[0].velocity

        if wait_right > 0 and wait_left > 0:
            while wait_right - 4 * tpb >= 0 and wait_left - 4 * tpb >= 0:
                wait_right -= 4 * tpb
                wait_left -= 4 * tpb
            seqr.elements.pop(0)
            seqr.elements.append(Element(MessageType.wait, wait_right, wait_right_velocity))
            seql.elements.pop(0)
            seql.elements.append(Element(MessageType.wait, wait_left, wait_left_velocity))

        musical = Musical(seqr, seql, numerator, denominator)
        return musical

    def to_midi_file(self):
        midi_file = MidiFile()
        tpb = Musical.ticks_per_beat
        midi_file.ticks_per_beat = tpb
        midi_file.type = 1

        right_track = self.right_hand.to_midi_track()
        right_track.insert(0, MetaMessage("track_name", name="Right Hand\x00", time=0))
        left_track = self.left_hand.to_midi_track()
        left_track.insert(0, MetaMessage("track_name", name="Left Hand\x00", time=0))
        midi_file.tracks.append(right_track)
        midi_file.tracks.append(left_track)
        return midi_file

    def detect_scale(self):
        return self.right_hand.detect_ideal_scale(), self.left_hand.detect_ideal_scale()

    def transpose(self, steps: int):
        self.right_hand.transpose(steps)
        self.left_hand.transpose(steps)
